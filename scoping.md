| Language             | Read from global inside fn | Write to global inside fn                                                                                                          | Special keyword needed?                                                             | Example & Behavior                                                                                                                                                                                                                                                        |
| -------------------- | -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Python**           | ✅ Yes (LEGB lookup)       | ❌ No → assignment makes a local by default → `UnboundLocalError` if you also read before assignment                               | `global` (for module vars), `nonlocal` (for outer fn vars)                          | <pre><code>py&#10;x = 10&#10;&#10;def f():&#10; print(x) # works&#10; # x += 1 # error: local before assignment&#10;&#10;def g():&#10; global x&#10; x += 1 # modifies global&#10;</code></pre>                                                                           |
| **JavaScript (ES6)** | ✅ Yes                     | ✅ Yes (modifies global if not shadowed; but `let/const` in local shadows cleanly)                                                 | None (`var` historically leaked globals, but with `let/const` you must be explicit) | <pre><code>js&#10;let x = 10;&#10;function f() {&#10; console.log(x); // 10&#10; x += 1; // modifies global&#10;}&#10;f();&#10;console.log(x); // 11&#10;</code></pre>                                                                                                    |
| **C**                | ✅ Yes                     | ✅ Yes (function can modify global unless local with same name exists → then shadows)                                              | None                                                                                | <pre><code>c&#10;#include &lt;stdio.h&gt;&#10;int x = 10;&#10;void f() {&#10; x += 1; // modifies global&#10; printf(&quot;%d\n&quot;, x);&#10;}&#10;int main() { f(); }&#10;</code></pre>                                                                                |
| **C++**              | ✅ Yes                     | ✅ Yes, same as C, but if shadowed by local you must use `::x` to reach global                                                     | None (but has `::` for disambiguation)                                              | <pre><code>cpp&#10;#include &lt;iostream&gt;&#10;int x = 10;&#10;void f() {&#10; int x = 5; // shadows global&#10; ::x += 1; // explicitly modifies global&#10; std::cout &lt;&lt; ::x &lt;&lt; &quot;\n&quot;;&#10;}&#10;</code></pre>                                   |
| **Rust**             | ✅ Yes                     | ❌ No, globals (`static` or `const`) are immutable by default. To mutate, must mark `static mut` and use `unsafe`.                 | `unsafe` for mut globals                                                            | <pre><code>rust&#10;static mut X: i32 = 10;&#10;fn f() {&#10; unsafe {&#10; X += 1; // allowed only in unsafe&#10; println!(&quot;{}&quot;, X);&#10; }&#10;}&#10;fn main() { f(); }&#10;</code></pre>                                                                     |
| **Go**               | ✅ Yes                     | ❌ No, you **cannot modify globals inside a function unless you _don’t redeclare_**. Assignment works, but `:=` will make a local. | None, just careful about `:=`                                                       | <pre><code>go&#10;package main&#10;import &quot;fmt&quot;&#10;var x = 10&#10;&#10;func f() {&#10; fmt.Println(x) // 10&#10; x = x + 1 // modifies global&#10; // y := x + 1 // would create a new local y&#10;}&#10;func main() { f(); fmt.Println(x) }&#10;</code></pre> |
